{
  "version": 3,
  "sources": ["../../src/lib/token.ts"],
  "sourcesContent": ["import { getOptionsAndSUrl } from './endPoints';\nimport { initStore as useStore } from './store';\nimport { updateDeviceID } from './updateDeviceId';\nimport { updateDeviceStatus } from './updateDeviceStatus';\nimport { errorLogger } from './logging';\nimport type { MidasAquatemp } from '../main';\nimport { request } from './axios';\n\nasync function getToken(adapter: MidasAquatemp): Promise<void> {\n    const store = useStore();\n\n    try {\n        const { token, apiLevel } = store;\n\n        if (!token) {\n            adapter.log.debug('Request token');\n            const { sUrl, options } = getOptionsAndSUrl();\n\n            const response = await request(adapter, sUrl, options);\n            if (!response) {\n                adapter.log.error('No response from server');\n                return;\n            }\n            if (response.status == 200) {\n                store.token =\n                    apiLevel < 3\n                        ? response.data?.object_result?.['x-token']\n                        : (store.token = response.data?.objectResult?.['x-token']);\n                if (store.token) {\n                    adapter.log.debug('Login ok! Token');\n                } else {\n                    adapter.log.error(`Login-error: ${JSON.stringify(response.data)}`);\n                }\n\n                return;\n            }\n\n            adapter.log.error(`Login-error: ${response.data}`);\n            store.resetOnErrorHandler();\n            return;\n        }\n    } catch (error) {\n        errorLogger('Error in getToken', error, adapter);\n    }\n}\n\nexport const updateToken = async (adapter: MidasAquatemp): Promise<void> => {\n    const store = useStore();\n    try {\n        await getToken(adapter);\n\n        if (!store.token) {\n            store.resetOnErrorHandler();\n            return;\n        }\n        if (store.useDeviceMac) {\n            await updateDeviceStatus(adapter);\n            return;\n        }\n        await updateDeviceID(adapter);\n        return;\n    } catch (error: any) {\n        errorLogger('Error in updateToken', error, adapter);\n    }\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAkC;AAClC,mBAAsC;AACtC,4BAA+B;AAC/B,gCAAmC;AACnC,qBAA4B;AAE5B,mBAAwB;AAExB,eAAe,SAAS,SAAuC;AAR/D;AASI,QAAM,YAAQ,aAAAA,WAAS;AAEvB,MAAI;AACA,UAAM,EAAE,OAAO,SAAS,IAAI;AAE5B,QAAI,CAAC,OAAO;AACR,cAAQ,IAAI,MAAM,eAAe;AACjC,YAAM,EAAE,MAAM,QAAQ,QAAI,oCAAkB;AAE5C,YAAM,WAAW,UAAM,sBAAQ,SAAS,MAAM,OAAO;AACrD,UAAI,CAAC,UAAU;AACX,gBAAQ,IAAI,MAAM,yBAAyB;AAC3C;AAAA,MACJ;AACA,UAAI,SAAS,UAAU,KAAK;AACxB,cAAM,QACF,WAAW,KACL,oBAAS,SAAT,mBAAe,kBAAf,mBAA+B,aAC9B,MAAM,SAAQ,oBAAS,SAAT,mBAAe,iBAAf,mBAA8B;AACvD,YAAI,MAAM,OAAO;AACb,kBAAQ,IAAI,MAAM,iBAAiB;AAAA,QACvC,OAAO;AACH,kBAAQ,IAAI,MAAM,gBAAgB,KAAK,UAAU,SAAS,IAAI,CAAC,EAAE;AAAA,QACrE;AAEA;AAAA,MACJ;AAEA,cAAQ,IAAI,MAAM,gBAAgB,SAAS,IAAI,EAAE;AACjD,YAAM,oBAAoB;AAC1B;AAAA,IACJ;AAAA,EACJ,SAAS,OAAO;AACZ,oCAAY,qBAAqB,OAAO,OAAO;AAAA,EACnD;AACJ;AAEO,MAAM,cAAc,OAAO,YAA0C;AACxE,QAAM,YAAQ,aAAAA,WAAS;AACvB,MAAI;AACA,UAAM,SAAS,OAAO;AAEtB,QAAI,CAAC,MAAM,OAAO;AACd,YAAM,oBAAoB;AAC1B;AAAA,IACJ;AACA,QAAI,MAAM,cAAc;AACpB,gBAAM,8CAAmB,OAAO;AAChC;AAAA,IACJ;AACA,cAAM,sCAAe,OAAO;AAC5B;AAAA,EACJ,SAAS,OAAY;AACjB,oCAAY,wBAAwB,OAAO,OAAO;AAAA,EACtD;AACJ;",
  "names": ["useStore"]
}
