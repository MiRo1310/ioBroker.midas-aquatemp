{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.6.3\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an\nimport { initStore } from \"./lib/store\";\n\nimport * as utils from \"@iobroker/adapter-core\";\nimport { createObjects } from \"./lib/createState\";\nimport { encryptPassword } from \"./lib/encryptPassword\";\nimport { setupEndpoints } from \"./lib/endPoints\";\nimport { saveValue } from \"./lib/saveValue\";\n\nimport { updateToken } from \"./lib/token\";\n\nimport { updateDevicePower } from \"./lib/updateDevicePower\";\nimport { updateDeviceSetTemp } from \"./lib/updateDeviceSetTemp\";\nimport { updateDeviceSilent } from \"./lib/updateDeviceSilent\";\n\nlet updateIntervall: ioBroker.Interval | undefined;\nlet tokenRefreshTimer: ioBroker.Interval | undefined;\n\nexport class MidasAquatemp extends utils.Adapter {\n\tprivate static instance: MidasAquatemp;\n\n\tpublic constructor(options: Partial<utils.AdapterOptions> = {}) {\n\t\tsuper({\n\t\t\t...options,\n\t\t\tname: \"midas-aquatemp\",\n\t\t});\n\t\tthis.on(\"ready\", this.onReady.bind(this));\n\t\tthis.on(\"unload\", this.onUnload.bind(this));\n\t\tMidasAquatemp.instance = this;\n\t}\n\tpublic static getInstance(): MidasAquatemp {\n\t\treturn MidasAquatemp.instance;\n\t}\n\n\tprivate async onReady(): Promise<void> {\n\t\tconst store = initStore();\n\t\tstore._this = this;\n\t\tstore.instance = this.instance;\n\n\t\tconst dpRoot = store.getDpRoot();\n\t\tthis.setState(\"info.connection\", false, true);\n\n\t\tstore.username = this.config.username;\n\t\tconst password = this.config.password;\n\t\tstore.interval = this.config.refresh;\n\t\tstore.apiLevel = this.config.selectApi;\n\t\tstore.device = this.config.deviceMac;\n\t\tstore.useDeviceMac = this.config.useDeviceMac;\n\t\tthis.log.debug(\"API-Level: \" + this.config.selectApi);\n\n\t\tsetupEndpoints();\n\t\tencryptPassword(password);\n\t\tawait createObjects();\n\t\tthis.log.info(\"Objects created\");\n\t\tclearValues();\n\t\tawait updateToken();\n\n\t\tfunction clearValues(): void {\n\t\t\tsaveValue(\"error\", true, \"boolean\");\n\t\t\tsaveValue(\"consumption\", 0, \"number\");\n\t\t\tsaveValue(\"state\", false, \"boolean\");\n\t\t\tsaveValue(\"rawJSON\", null, \"string\");\n\t\t}\n\n\t\tupdateIntervall = store._this.setInterval(async () => {\n\t\t\ttry {\n\t\t\t\tawait updateToken();\n\t\t\t\tconst mode = await store._this.getStateAsync(dpRoot + \".mode\");\n\n\t\t\t\tif (mode && !mode.ack && mode.val) {\n\t\t\t\t\tupdateDevicePower(store.device, mode.val as number);\n\t\t\t\t}\n\t\t\t\tconst silent = await this.getStateAsync(dpRoot + \".silent\");\n\t\t\t\tif (silent && !silent.ack && silent.val) {\n\t\t\t\t\tupdateDevicePower(store.device, silent.val as number);\n\t\t\t\t}\n\t\t\t} catch (error: any) {\n\t\t\t\tstore._this.log.error(JSON.stringify(error));\n\t\t\t\tstore._this.log.error(JSON.stringify(error.stack));\n\t\t\t}\n\t\t}, store.interval * 1000);\n\n\t\ttokenRefreshTimer = this.setInterval(async function () {\n\t\t\tstore.token = \"\";\n\t\t\tstore._this.log.info(\"Token will be refreshed.\");\n\t\t\tawait updateToken();\n\t\t}, 3600000);\n\n\t\tthis.on(\"stateChange\", async (id, state) => {\n\t\t\ttry {\n\t\t\t\tif (id === dpRoot + \".mode\" && state && !state.ack) {\n\t\t\t\t\tthis.log.debug(\"Mode: \" + JSON.stringify(state));\n\t\t\t\t\tif (state && state.val) {\n\t\t\t\t\t\tupdateDevicePower(store.device, state.val as number);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (id === dpRoot + \".silent\" && state && !state.ack) {\n\t\t\t\t\tthis.log.debug(\"Silent: \" + JSON.stringify(state));\n\t\t\t\t\tif (state && state.val) {\n\t\t\t\t\t\tupdateDeviceSilent(store.device, state.val as boolean);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (id === dpRoot + \".tempSet\" && state && !state.ack) {\n\t\t\t\t\tthis.log.debug(\"TempSet: \" + JSON.stringify(state));\n\n\t\t\t\t\tif (state && state.val) {\n\t\t\t\t\t\tupdateDeviceSetTemp(store.device, state.val as number);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error: any) {\n\t\t\t\tstore._this.log.error(JSON.stringify(error));\n\t\t\t\tstore._this.log.error(JSON.stringify(error.stack));\n\t\t\t}\n\t\t});\n\n\t\tawait this.subscribeStatesAsync(dpRoot + \".mode\");\n\t\tawait this.subscribeStatesAsync(dpRoot + \".silent\");\n\t\tawait this.subscribeStatesAsync(dpRoot + \".tempSet\");\n\t}\n\n\t/**\n\t * Is called when adapter shuts down - callback has to be called under any circumstances!\n\t */\n\tprivate onUnload(callback: () => void): void {\n\t\ttry {\n\t\t\tthis.clearInterval(updateIntervall);\n\t\t\tthis.clearInterval(tokenRefreshTimer);\n\n\t\t\tcallback();\n\t\t} catch (e) {\n\t\t\tcallback();\n\t\t}\n\t}\n}\nlet adapter;\n\nif (require.main !== module) {\n\t// Export the constructor in compact mode\n\tadapter = (options: Partial<utils.AdapterOptions> | undefined) => new MidasAquatemp(options);\n} else {\n\t// otherwise start the instance directly\n\t(() => new MidasAquatemp())();\n}\nexport { adapter };\n"],
  "mappings": "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",
  "names": []
}
